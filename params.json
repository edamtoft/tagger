{"name":"Tagger","tagline":"Framework for declaring and automatically resolving custom web components based on their tags","body":"# Tagger\r\n\r\nTagger is a front-end javascript runtime based around the \r\nidea that you should be able to extend and modularize HTML with web components\r\nwithout having to worry about when and where to load\r\nwhat, and with the development overhead to build components. Tagger leverages\r\nthe power of require.js to automatically handle dependency resolution throught\r\nyour project, so all you have to do is create your components. Tagger does \r\nnot aim to be a all-encompassing framework. Though it provides a range of system \r\nlibraries to make many common frontend tasks easier, it makes few\r\nassumptions about how to use it or what it can work with. Feel free to mix\r\nthis in with your favorite other libraries and tools.\r\n\r\n## What it does\r\n\r\nTagger automatically resolves everything you need based on what's on the \r\ncurrent page. No matter how many components you have on the page, you\r\nonly need to include tagger.js in a script tag.\r\n\r\nLet's say you want to create a custom component says hello to someone based on\r\na property.\r\n\r\nStart off by naming your custom component. Per W3 specifications,\r\ncustom tags must be two or more words separated by dashes. Let's call this one\r\nsample-component\r\n\r\nIn your markup, create the following:\r\n\r\n```\r\n<sample-component name=\"World\"></sample-component>\r\n```\r\n\r\nIn the controllers folder of the runtime, create a file called sampleComponentController.js:\r\n\r\n```\r\ndefine([\r\n\t\"system/text\"\r\n], function(text) {\r\n\t\r\n\t\"use strict\";\r\n\t\r\n\tfunction SampleComponentController(element, config) {\r\n\t\telement.innerHTML = text.from(\"<h1>Hello {name}</h1>\");\r\n\t}\r\n\t\r\n\treturn SampleComponentController;\r\n});\r\n```\r\n\r\ntext.from is a system runtime helper that interpolates objects into strings. More on these libraries\r\nlater.\r\n\r\nOpen a terminal in the project root and run \"grunt\" to compile the project (you'll need \r\nnode.js and grunt. See Installation), open the HTML page, and you component should \r\nautomatically boot up. You should see the following:\r\n\r\n```\r\n<sample-component name=\"World\">\r\n\t<h1>Hello World</h1>\r\n</sample-component>\r\n```\r\n\r\nFor a more practical (though more complex) example, see the google map component in the\r\ncontrollers folder.\r\n\r\n## Installation\r\n\r\nTo start, fork this repo and clone it. You will need to install node.js and grunt.\r\n\r\nto install node, goto https://nodejs.org/en/ and download and run the installer for your platform.\r\n\r\nnext, open a terminal window and run the following to install grunt (the task runner/compiler for our modules):\r\n```\r\nnpm install grunt-cli -g\r\n```\r\nnext, navigate in the terminal to the root of this project and run:\r\n```\r\nnpm install --dev\r\n```\r\nto install the build dependencies.\r\n\r\nmake your controllers in the source folder, and run \"grunt\" from the terminal to compile. By default, it runs jshint to\r\ndetect javascript errors.\r\n\r\nIf you use Visual Studio Code, it is already set to build automatically with ctrl+shift+b.\r\n\r\n### Don't want to install anything?\r\n\r\nThat's fine too. You just won't get automatic compression / optimization checks of new modules/controllers.\r\n\r\nDownload just the \"bin\" folder (the whole folder, not just tagger.js), and start writing controllers in the controllers folder. Feel free to delete the samples.\r\n\r\n\r\n## Build in MVC Functionality\r\n\r\nThis is still under construction, but here's how it works:\r\n\r\nMarkup:\r\n```\r\n<sample-mvc-component>\r\n\t<h4 model=\"test\"></h4>\r\n\t<input type=\"text\" model=\"test\" />\r\n\t<button event=\"clickHappened\">Alert Me</button>\r\n</sample-mvc-component>\r\n```\r\n\r\nController:\r\n```\r\ndefine([], function() {\r\n\t\r\n\tfunction SampleMvcController(element, config) {\r\n\t\t\r\n\t\tthis.clickHappened = function() {\r\n\t\t\talert(this.model.test);\r\n\t\t};\r\n\t}\r\n\t \t\r\n\treturn SamplMvcController;\r\n});\r\n```\r\nThe H4 tag and the input will be automatically bound in real time. When you click the button, \r\nit will call the clickHappened function on the controller, no additional wire-up needed.\r\n\r\nIf you include a this.modelChanged function in the controller, it will be called when any part of the\r\nmodel is changed.\r\n\r\nThis aspect is still experimental and will remain rudamentary for a while. If you need additional\r\nfunctionality, combining this with another MVC library. \r\n\r\n## Config Options\r\n\r\nIf you need to pass in more config options than will easily fit as attributes, you can add a script tag\r\nof type=\"application/JSON\" with role=\"config\" inside the component with config as JSON.\r\n\r\nmulti-word config keys are collapsed to camelCase when resolving keys from the component attributes.\r\n\r\n```\r\n<google-map>\r\n\t<script type=\"application/JSON\" role=\"config\">\r\n\t{\r\n\t\t\"address\":\"some long address\",\r\n\t\t\"key\":\"loiasdf9yh3r893yh5r43982492834\",\r\n\t\t\"info\":\"<h4>Info Window Title</h4><p>Marker Description</p>\"\t\r\n\t}\r\n\t</script>\r\n</google-map>\r\n\r\n```\r\n\r\n## System Libraries\r\nTagger comes pre-installed with a number of system libraries which provide an easy-to-use and\r\nreusable wrappers around many common operations. These can be accessed through require-js's \r\nsyntax.\r\n\r\nWhen defining dependencies for a controller (or other module):\r\n```\r\ndefine([\r\n\t\"system/text\", \r\n\t\"system/http\"\r\n], function(text, http) {\r\n\t\r\n\t// text and http are available here.\r\n\t\r\n});\r\n\r\n```\r\n\r\nOr on it's own:\r\n```\r\nrequire([\r\n\t\"system/text\", \r\n\t\"system/http\"\r\n], function(text, http) {\r\n\t\r\n\t// text and http are available here.\r\n});\r\n```\r\n\r\n### Text\r\n\r\nInterpolates and manipulates text similarly to string.Format in c#\r\n\r\n```\r\n\tvar yourName = \"you\";\r\n\tvar myName = \"me\";\r\n\t\r\n\ttext.from(\"hello {0}, my name is {1}\", yourName, myName);\t\r\n```\r\n\r\nyou can also enter it by property name in an object\r\n\r\n```\r\n\tvar props = {\r\n\t\tyourName: \"you\",\r\n\t\tmyName: \"me\"\t\r\n\t};\r\n\t\r\n\ttext.from(\"hello {yourName}, my name is {myName}\", props);\r\n```\r\n\r\nyou can also parse a querystring to an object or serialize one from an object:\r\n\r\n```\r\n\tvar query = {\r\n\t\tpage: 1,\r\n\t\ttype: \"sample type\" \t\r\n\t};\r\n\t\r\n\tvar serialized = text.toQuery(query); //page=1&type=sample%20type\r\n\t\r\n\tvar deserialized = text.fromQuery(serialized);\r\n\t\r\n\tdesirialized.type // returns \"sample type\";\r\n```\r\n### http\r\n\r\nHttp aims to make it easier to handle making calls to REST api endpoints. See the following example:\r\n\r\n```\r\n\tvar params = {\r\n\t\ttopic: \"sometopic\",\r\n\t\tsubtopic: \"somesubtopic\"\t\r\n\t};\r\n\t\r\n\thttp.get(\"/api/{topic}/{subtopic}\", params)\r\n\t.success(function(response){\r\n\t\t// response will be automatically parsed if it's a JSON response\r\n\t})\r\n\t.error(function() {\r\n\t\talert(\"Call failed\");\t\r\n\t});\r\n```\r\nThis will send a HTTP get to \"/api/sometopic/somesubtopic\" and will then call either the success or error\r\ncallback. Text in the params is automatically interpolated using the same engine as text.js\r\n\r\nand for a post:\r\n\r\n```\r\n\tvar params = {\r\n\t\ttopic: \"sometopic\",\r\n\t\tsubtopic: \"somesubtopic\"\t\r\n\t};\r\n\t\r\n\thttp.post(\"/api/{topic}/{subtopic}\", params)\r\n\t.send({\r\n\t\tdata: \"data\",\r\n\t\totherData: \"otherData\"\t\r\n\t})\r\n\t.success(function(response){\r\n\t\t\r\n\t\t// response will be automatically parsed if it's a JSON response\r\n\t\t\r\n\t});\r\n\r\n```\r\nThis will automatically send the supplied data encoded as JSON with the proper content-type headers to the\r\nsame endpoint as before.\r\n\r\nFor a more complex example:\r\n\r\n ```\r\n\tvar params = {\r\n\t\ttopic: \"sometopic\",\r\n\t\tsubtopic: \"somesubtopic\"\t\r\n\t};\r\n\t\r\n\thttp.post(\"/api/{topic}/{subtopic}\", params)\r\n\t.withBasicAuth(\"username\",\"password\")\r\n\t.withQuery({\r\n\t\textraData: \"extra data\"\t\r\n\t})\r\n\t.send({\r\n\t\tdata: \"data\",\r\n\t\totherData: \"otherData\"\t\r\n\t})\r\n\t.success(function(response){\r\n\t\t\r\n\t\t// response will be automatically parsed if it's a JSON response\r\n\t\t\r\n\t});\r\n```\r\n\r\nThis will send a request to \"/api/sometopic/somesubtopic/?extraData=extra&20data\" with an encoded HTTP basic auth\r\nheader with the supplied user name and password. To use a different type of auth, call .withAuth(type, credentials).\r\nYou can also add custom headers by calling .withHeader(name, value) one or more times.\r\n\r\n### enumerable\r\n\r\nBasically a javascript copy of c# linq.\r\n\r\nExamples:\r\n\r\n```\r\n\tvar elements = document.querySelectorAll(\"*\");\r\n\t\r\n\tenumerable.of(elements)\r\n\t\t.where(function(e) { return e.tagName == \"IMG\" || e.style.backgroundImage > \"\"; })\r\n\t\t.select(function(e) { return e.style.height; })\r\n\t\t.distinct()\r\n\t\t.toArray();\r\n```\r\nThis would return a simple array of image-like elements's distinct heights. To find the size of the one:\r\n\r\n```\r\n\tenumerable.of(elements)\r\n\t\t.where(function(e) { return e.tagName == \"IMG\" || e.style.backgroundImage > \"\"; })\r\n\t\t.max(function(e) { return e.style.height; });\r\n```\r\n\r\nAnd to iterate over a list:\r\n```\r\n\tenumerable.of(collection).each(function(item) { \r\n\t\t// do stuff\r\n\t});\r\n```\r\n### logManager\r\n\r\nprovides an easy framework for logging messages in modules, using the text.js engine.\r\n\r\n```\r\n\tvar log = logManager.getLogger(\"Logger Name\");\r\n\t\r\n\tlog.info(\"Something happend. Details: {0}\", details);\r\n\t\r\n\tlog.error(\"Something bad happend. Details: {0}\", details);\r\n```\r\n\r\nYou can call logManager.get() to get the full text of all logs for the page with detailed timestamps.\r\n\r\nYou can set the logger display level (default to INFO) with the following:\r\n```\r\n\tlogManager.logLevel = logManager.levels.DEBUG\r\n\t\r\n\t// DEBUG, INFO, WARN, ERROR\r\n```\r\n\r\n### guid\r\n\r\nReturns v4 guids. Not cryptographically secure, but plenty random for everyday use.\r\n```\r\n\tguid.create() // => 621398fa-5b37-4164-98ff-6c845aa6c61c\r\n\t\r\n\tguid.createMany(2) // => array of 2 guids \r\n```\r\n\r\n### promise\r\n\r\nsimple promise library.\r\n\r\n Sample:\r\n\r\n```\r\n\tvar myPromise = promise.that(function(resolve, reject) {\r\n\t\tdo.some.async.work\r\n\t\t\t.success(function(data) {\r\n\t\t\t\tresolve(data);\r\n\t\t\t})\r\n\t\t\t.error(function(err) {\r\n\t\t\t\treject(err);\r\n\t\t\t});\r\n\t});\r\n\t\r\n\tmyPromise.then(function(err, data) {\r\n\t\tif (err) {\r\n\t\t\t// handle error\t\r\n\t\t}\r\n\t\t\r\n\t\t// use data\r\n\t});\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}